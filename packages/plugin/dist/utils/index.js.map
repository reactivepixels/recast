{"version":3,"sources":["../../src/utils/index.ts"],"sourcesContent":["import util from \"util\";\n\n/**\n * Logs debug information with formatted output.\n * @param {string} label - The label for the debug information.\n * @param {any} data - The data to be logged.\n */\nexport function debugLog(label: string, data: any) {\n  console.log(\n    `DEBUG - ${label}:`,\n    util.inspect(data, { depth: null, colors: true })\n  );\n}\n\nexport interface RecastComponent {\n  base?: string | string[] | Record<string, string | string[]>;\n  variants?: Record<\n    string,\n    Record<string, string | string[] | Record<string, string | string[]>>\n  >;\n}\n\nexport interface RecastUsage {\n  componentName: string;\n  props: Record<string, any>;\n}\n\n/**\n * Parses Recast component definitions from the given content.\n * @param {string} content - The content to parse for Recast components.\n * @returns {Record<string, RecastComponent>} An object containing parsed Recast components.\n */\nexport function parseRecastComponents(\n  content: string\n): Record<string, RecastComponent> {\n  const componentRegex =\n    /(?:export\\s+(?:const|default)|const)\\s+(\\w+)\\s*=\\s*recast\\s*\\(\\s*\\w+\\s*,\\s*({[\\s\\S]*?})\\s*\\)/g;\n  const components: Record<string, RecastComponent> = {};\n\n  let match;\n  while ((match = componentRegex.exec(content)) !== null) {\n    const [, componentName, componentDef] = match;\n    try {\n      const processedDef = componentDef\n        .replace(/(['\"])?([a-zA-Z0-9_]+)(['\"])?:/g, '\"$2\": ')\n        .replace(/'/g, '\"')\n        .replace(/,\\s*}/g, \"}\")\n        .replace(/\\n/g, \" \")\n        .trim();\n      components[componentName] = JSON.parse(processedDef);\n    } catch (e) {\n      console.error(`Error parsing component ${componentName}:`, e);\n    }\n  }\n\n  // Handle default exports\n  const defaultExportRegex = /export\\s+default\\s+(\\w+)/;\n  const defaultExportMatch = content.match(defaultExportRegex);\n  if (defaultExportMatch) {\n    const componentName = defaultExportMatch[1];\n    if (components[componentName]) {\n      components[\"default\"] = components[componentName];\n    }\n  }\n\n  return components;\n}\n\n/**\n * Parses Recast component usages from the given content.\n * @param {string} content - The content to parse for Recast usages.\n * @returns {RecastUsage[]} An array of parsed Recast usages.\n */\nexport function parseRecastUsages(content: string): RecastUsage[] {\n  const usageRegex = /<(\\w+)([^>]*)>/g;\n  return Array.from(content.matchAll(usageRegex)).map(\n    ([, componentName, propsString]) => ({\n      componentName,\n      props: parseProps(propsString),\n    })\n  );\n}\n\n/**\n * Parses props from a string representation.\n * @param {string} propsString - The string containing props to parse.\n * @returns {Record<string, any>} An object containing parsed props.\n */\nexport function parseProps(propsString: string): Record<string, any> {\n  const props: Record<string, any> = {};\n  const propsRegex =\n    /(\\w+)\\s*=\\s*({[^}]+}|\"[^\"]*\"|{`[^`]+`}|\\w+|{true}|{false})/g;\n\n  for (const [, key, value] of propsString.matchAll(propsRegex)) {\n    if ([\"ref\", \"className\", \"style\"].includes(key)) continue;\n\n    if (value.startsWith(\"{\") && value.endsWith(\"}\")) {\n      if (value === \"{true}\") {\n        props[key] = true;\n      } else if (value === \"{false}\") {\n        props[key] = false;\n      } else {\n        try {\n          const processedValue = value\n            .replace(/'/g, '\"')\n            .replace(/(\\w+):/g, '\"$1\":')\n            .replace(/\\s+/g, \"\")\n            .replace(/{{/g, \"{\")\n            .replace(/}}/g, \"}\");\n          props[key] = JSON.parse(processedValue);\n        } catch (e) {\n          console.error(`Error parsing prop ${key}:`, e);\n          props[key] = value;\n        }\n      }\n    } else if (value.startsWith('\"') && value.endsWith('\"')) {\n      props[key] = value.slice(1, -1);\n    } else {\n      props[key] = value;\n    }\n  }\n  return props;\n}\n\n/**\n * Extracts file patterns from the content configuration.\n * @param {any} contentConfig - The content configuration object.\n * @returns {string[]} An array of file patterns.\n */\nexport function getFilePatterns(contentConfig: any): string[] {\n  if (typeof contentConfig === \"string\") return [contentConfig];\n  if (Array.isArray(contentConfig))\n    return contentConfig.flatMap(getFilePatterns);\n  if (typeof contentConfig === \"object\" && contentConfig !== null) {\n    return getFilePatterns(contentConfig.files || []);\n  }\n  return [];\n}\n\n/**\n * Adds classes to the safelist with the given prefix.\n * @param {Set<string>} safelist - The set to add safelist items to.\n * @param {string | string[] | Record<string, string | string[]>} classes - The classes to add to the safelist.\n * @param {string} [prefix=\"\"] - The prefix to apply to the classes.\n */\nexport function addToSafelist(\n  safelist: Set<string>,\n  classes: string | string[] | Record<string, string | string[]>,\n  prefix: string = \"\"\n): void {\n  if (!prefix) return;\n\n  const addClassWithPrefix = (cls: string) => safelist.add(`${prefix}:${cls}`);\n\n  if (typeof classes === \"string\") {\n    classes.split(/\\s+/).forEach(addClassWithPrefix);\n  } else if (Array.isArray(classes)) {\n    classes.forEach(addClassWithPrefix);\n  } else if (typeof classes === \"object\" && classes !== null) {\n    Object.entries(classes).forEach(([breakpoint, breakpointClasses]) => {\n      if (breakpoint !== \"default\") {\n        addToSafelist(safelist, breakpointClasses, breakpoint);\n      }\n    });\n  }\n}\n"],"mappings":"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","names":[]}