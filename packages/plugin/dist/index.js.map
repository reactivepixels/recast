{"version":3,"sources":["../src/index.ts","../src/utils/index.ts"],"sourcesContent":["import plugin from \"tailwindcss/plugin\";\nimport fs from \"fs\";\nimport { glob } from \"glob\";\nimport {\n  parseRecastComponents,\n  parseRecastUsages,\n  getFilePatterns,\n  addToSafelist,\n  RecastComponent,\n  RecastUsage,\n} from \"./utils\";\n\n/**\n * Recast Tailwind Plugin\n *\n * This plugin processes Recast component definitions and usages to generate\n * a safelist of Tailwind CSS classes, ensuring that all necessary classes\n * are included in the final CSS output, even when not explicitly used in the markup.\n */\nexport default plugin(function ({ config }) {\n  /**\n   * Set to store unique safelist entries\n   * @type {Set<string>}\n   */\n  const safelist = new Set<string>();\n\n  /**\n   * Object to store parsed Recast components\n   * @type {Record<string, RecastComponent>}\n   */\n  const components: Record<string, RecastComponent> = {};\n\n  /**\n   * Array to store parsed Recast component usages\n   * @type {RecastUsage[]}\n   */\n  const usages: RecastUsage[] = [];\n\n  /**\n   * Content configuration from Tailwind config\n   * @type {any}\n   */\n  const contentConfig = config(\"content\");\n\n  try {\n    if (\n      typeof contentConfig === \"object\" &&\n      contentConfig !== null &&\n      \"files\" in contentConfig &&\n      Array.isArray(contentConfig.files) &&\n      contentConfig.files.length > 0 &&\n      typeof contentConfig.files[0] === \"object\" &&\n      contentConfig.files[0].raw\n    ) {\n      // Test environment: content is passed directly\n      Object.assign(\n        components,\n        parseRecastComponents(contentConfig.files[0].raw)\n      );\n      usages.push(...parseRecastUsages(contentConfig.files[0].raw));\n    } else {\n      // Real-world scenario: process file patterns\n      const filePatterns = getFilePatterns(contentConfig);\n      filePatterns.forEach((pattern) => {\n        const files = glob.sync(pattern);\n        files.forEach((file) => {\n          const content = fs.readFileSync(file, \"utf8\");\n          Object.assign(components, parseRecastComponents(content));\n          usages.push(...parseRecastUsages(content));\n        });\n      });\n    }\n  } catch (error) {\n    // Error handling without console.log\n  }\n\n  /**\n   * Process each usage to generate safelist entries\n   */\n  usages.forEach((usage) => {\n    const component = components[usage.componentName];\n    if (!component) return;\n\n    Object.entries(usage.props).forEach(([propName, propValue]) => {\n      const variantGroup = component.variants?.[propName];\n      if (!variantGroup) return;\n\n      if (typeof propValue === \"object\" && propValue !== null) {\n        Object.entries(propValue).forEach(([breakpoint, value]) => {\n          if (breakpoint !== \"default\" && typeof value === \"string\") {\n            const classes = variantGroup[value];\n            if (classes) {\n              addToSafelist(safelist, classes, breakpoint);\n            }\n          }\n        });\n      }\n    });\n  });\n\n  /**\n   * Set the safelist in the Tailwind config\n   */\n  config().safelist = Array.from(safelist);\n});\n","import util from \"util\";\n\n/**\n * Logs debug information with formatted output.\n * @param {string} label - The label for the debug information.\n * @param {any} data - The data to be logged.\n */\nexport function debugLog(label: string, data: any) {\n  console.log(\n    `DEBUG - ${label}:`,\n    util.inspect(data, { depth: null, colors: true })\n  );\n}\n\nexport interface RecastComponent {\n  base?: string | string[] | Record<string, string | string[]>;\n  variants?: Record<\n    string,\n    Record<string, string | string[] | Record<string, string | string[]>>\n  >;\n}\n\nexport interface RecastUsage {\n  componentName: string;\n  props: Record<string, any>;\n}\n\n/**\n * Parses Recast component definitions from the given content.\n * @param {string} content - The content to parse for Recast components.\n * @returns {Record<string, RecastComponent>} An object containing parsed Recast components.\n */\nexport function parseRecastComponents(\n  content: string\n): Record<string, RecastComponent> {\n  const componentRegex =\n    /(?:export\\s+(?:const|default)|const)\\s+(\\w+)\\s*=\\s*recast\\s*\\(\\s*\\w+\\s*,\\s*({[\\s\\S]*?})\\s*\\)/g;\n  const components: Record<string, RecastComponent> = {};\n\n  let match;\n  while ((match = componentRegex.exec(content)) !== null) {\n    const [, componentName, componentDef] = match;\n    try {\n      const processedDef = componentDef\n        .replace(/(['\"])?([a-zA-Z0-9_]+)(['\"])?:/g, '\"$2\": ')\n        .replace(/'/g, '\"')\n        .replace(/,\\s*}/g, \"}\")\n        .replace(/\\n/g, \" \")\n        .trim();\n      components[componentName] = JSON.parse(processedDef);\n    } catch (e) {\n      console.error(`Error parsing component ${componentName}:`, e);\n    }\n  }\n\n  // Handle default exports\n  const defaultExportRegex = /export\\s+default\\s+(\\w+)/;\n  const defaultExportMatch = content.match(defaultExportRegex);\n  if (defaultExportMatch) {\n    const componentName = defaultExportMatch[1];\n    if (components[componentName]) {\n      components[\"default\"] = components[componentName];\n    }\n  }\n\n  return components;\n}\n\n/**\n * Parses Recast component usages from the given content.\n * @param {string} content - The content to parse for Recast usages.\n * @returns {RecastUsage[]} An array of parsed Recast usages.\n */\nexport function parseRecastUsages(content: string): RecastUsage[] {\n  const usageRegex = /<(\\w+)([^>]*)>/g;\n  return Array.from(content.matchAll(usageRegex)).map(\n    ([, componentName, propsString]) => ({\n      componentName,\n      props: parseProps(propsString),\n    })\n  );\n}\n\n/**\n * Parses props from a string representation.\n * @param {string} propsString - The string containing props to parse.\n * @returns {Record<string, any>} An object containing parsed props.\n */\nexport function parseProps(propsString: string): Record<string, any> {\n  const props: Record<string, any> = {};\n  const propsRegex =\n    /(\\w+)\\s*=\\s*({[^}]+}|\"[^\"]*\"|{`[^`]+`}|\\w+|{true}|{false})/g;\n\n  for (const [, key, value] of propsString.matchAll(propsRegex)) {\n    if ([\"ref\", \"className\", \"style\"].includes(key)) continue;\n\n    if (value.startsWith(\"{\") && value.endsWith(\"}\")) {\n      if (value === \"{true}\") {\n        props[key] = true;\n      } else if (value === \"{false}\") {\n        props[key] = false;\n      } else {\n        try {\n          const processedValue = value\n            .replace(/'/g, '\"')\n            .replace(/(\\w+):/g, '\"$1\":')\n            .replace(/\\s+/g, \"\")\n            .replace(/{{/g, \"{\")\n            .replace(/}}/g, \"}\");\n          props[key] = JSON.parse(processedValue);\n        } catch (e) {\n          console.error(`Error parsing prop ${key}:`, e);\n          props[key] = value;\n        }\n      }\n    } else if (value.startsWith('\"') && value.endsWith('\"')) {\n      props[key] = value.slice(1, -1);\n    } else {\n      props[key] = value;\n    }\n  }\n  return props;\n}\n\n/**\n * Extracts file patterns from the content configuration.\n * @param {any} contentConfig - The content configuration object.\n * @returns {string[]} An array of file patterns.\n */\nexport function getFilePatterns(contentConfig: any): string[] {\n  if (typeof contentConfig === \"string\") return [contentConfig];\n  if (Array.isArray(contentConfig))\n    return contentConfig.flatMap(getFilePatterns);\n  if (typeof contentConfig === \"object\" && contentConfig !== null) {\n    return getFilePatterns(contentConfig.files || []);\n  }\n  return [];\n}\n\n/**\n * Adds classes to the safelist with the given prefix.\n * @param {Set<string>} safelist - The set to add safelist items to.\n * @param {string | string[] | Record<string, string | string[]>} classes - The classes to add to the safelist.\n * @param {string} [prefix=\"\"] - The prefix to apply to the classes.\n */\nexport function addToSafelist(\n  safelist: Set<string>,\n  classes: string | string[] | Record<string, string | string[]>,\n  prefix: string = \"\"\n): void {\n  if (!prefix) return;\n\n  const addClassWithPrefix = (cls: string) => safelist.add(`${prefix}:${cls}`);\n\n  if (typeof classes === \"string\") {\n    classes.split(/\\s+/).forEach(addClassWithPrefix);\n  } else if (Array.isArray(classes)) {\n    classes.forEach(addClassWithPrefix);\n  } else if (typeof classes === \"object\" && classes !== null) {\n    Object.entries(classes).forEach(([breakpoint, breakpointClasses]) => {\n      if (breakpoint !== \"default\") {\n        addToSafelist(safelist, breakpointClasses, breakpoint);\n      }\n    });\n  }\n}\n"],"mappings":"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","names":[]}